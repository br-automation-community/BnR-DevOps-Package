<#
.SYNOPSIS
    Generates a JSON compile command database from an AS project.

.DESCRIPTION
    This script will create a JSON compile command database based on the
    content of an AS project. The compile commands will be based on the GCC
    options for the specified configuration.

.PARAMETER Project
    The root folder of the AS project.

.PARAMETER Configuration
    The name of the software configuration to use when creating the compile
    commands.

.PARAMETER DatabaseFile
    The name of the database file that will be created. If the file already
    exists, it will be overwritten.

.PARAMETER FileListFile
    The name of the file list file that will be created. If the file already
    exists, it will be overwritten.

.PARAMETER References
    If defined, files, packages and libraries that are referenced will be
    included in the database.

.PARAMETER Exclude
    A list of wildcard patterns used to exclude source files from the database.
    By default, all *.cpp files are included.

.PARAMETER Warnings
    A list of warning options that should be passed to the compiler.

.PARAMETER HeaderPrefixes
    A list of header prefixes that indicates that an header should be treated
    as a system header an be excluded from any compiler output.

.PARAMETER OverrideInclude
    A list of header include paths that should be placed before any other
    include paths in order to enable overriding headers.

.PARAMETER AsHome
    The Automation Studio installation directory used to locate the required
    GCC installation. If AS is installed in "C:\BrAutomation\AS40" then the
    home directory is  "C:\BrAutomation\AS40"

.PARAMETER AsDefault
    If specified, the compile commands will be adapted to work with any
    AsDefault.h files generated by Automation Studio.
#>
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$True)]
    [string]$Project,

    [Parameter(Mandatory=$True)]
    [string]$Configuration,

    [Parameter(Mandatory=$True)]
    [string]$DatabaseFile,

    [Parameter(Mandatory=$True)]
    [string]$FileListFile,

    [Parameter(Mandatory=$False)]
    [switch]$References,

    [Parameter(Mandatory=$False)]
    [string[]]$Exclude,

    [Parameter(Mandatory=$False)]
    [string[]]$Warnings,

    [Parameter(Mandatory=$False)]
    [string[]]$HeaderPrefixes,

    [Parameter(Mandatory=$False)]
    [string[]]$OverrideInclude,

    [Parameter(Mandatory=$False)]
    [string]$AsHome,

    [Parameter(Mandatory=$False)]
    [switch]$AsDefault
)

# ------------------------------------------------------------------------------

$scriptPath = split-path -parent $MyInvocation.MyCommand.Definition
$helperPath = join-path $scriptPath "helpermod.psm1"
$optionsPath = join-path $scriptPath "Read-AsBuildOptions.ps1"
$contentPath = join-path $scriptPath "Get-AsContent.ps1"

Import-Module $helperPath

# ------------------------------------------------------------------------------

$content = ""

function AppendL($content) {
    $script:content += $content
    $script:content += "`n"
}

# ------------------------------------------------------------------------------

$clangCArguments = @()
$clangCppArguments = @()

# ------------------------------------------------------------------------------

function JsonEscape($string) {
    $string.Replace("\", "/")
}

# ------------------------------------------------------------------------------

function GetGCCLocation($gccVersion) {
    if ($script:AsHome) {
        $asLocation = $script:AsHome
        if (!(Test-path $asLocation)) {
            throw "AS installation could not be located at $asLocation"
        }
    } else {
        # Search at default locations
        $asLocation = GetASLocation($Project)
    }
    $subFolder = "AS\gnuinst\V"
    $subFolder += $gccVersion;
    $gccLocation = Join-Path $asLocation $subFolder
    $gccLocation = Join-Path $gccLocation "4.9"
    if (!(Test-path $gccLocation)) {
        throw "AS GCC installation could not be located at $gccLocation"
    }
    return $gccLocation
}

# ------------------------------------------------------------------------------

function GetDefaultASIncludeDirectories($project, $gccVersion, $isCpp) {
    $gccLocation = GetGCCLocation($gccVersion)
    $directories = @()

    # Default GCC directories required for C++
    if ($gccVersion -eq "4.1.2") {
      $directories += Join-Path $gccLocation "lib\gcc\i386-elf\4.1.2\include"
      $directories += Join-Path $gccLocation "i386-elf\include"
      if ($isCpp -eq $true){
        $directories += Join-Path $gccLocation "include\c++\4.1.2"
        $directories += Join-Path $gccLocation "include\c++\4.1.2\i386-elf"
      }
    } else {
      $directories += Join-Path $gccLocation "lib\gcc\i686-elf\6.3.0\include"
      $directories += Join-Path $gccLocation "lib\gcc\i686-elf\6.3.0\include-fixed"
      $directories += Join-Path $gccLocation "i686-elf\include"
      if ($isCpp -eq $true){
        $directories += Join-Path $gccLocation "i686-elf\include\c++\6.3.0"
        $directories += Join-Path $gccLocation "i686-elf\include\c++\6.3.0\bits"
        $directories += Join-Path $gccLocation "i686-elf\include\c++\6.3.0\i686-elf"
      }
    }

    # Default AS directories
    $directories += Join-Path $project "Temp\Includes"

    $directories
}

# ------------------------------------------------------------------------------

function MakeCommandLine($file, $options, $asIncludes, $packageOptions, $clangArguments) {
    # Dummy clang command
    $command = "clang.exe"

    # Override include directories should go first
    if ($script:OverrideInclude -ne $null) {
        foreach ($dir in $script:OverrideInclude) {
            $dir = JsonEscape $dir
            $command += " -isystem`\`"$dir`\`""
        }
    }

    # Program specific AsDefault paths
    if ($script:AsDefault) {
        if ($packageOptions -and $packageOptions.AsDefaultPaths) {
            foreach ($dir in $packageOptions.AsDefaultPaths) {
                $dir = JsonEscape $dir
                $command += " -isystem`\`"$dir`\`""
            }
        }
    }

    # Default AS include directories
    foreach ($dir in $asIncludes) {
        $dir = JsonEscape $dir
        $command += " -isystem`\`"$dir`\`""
    }

    # Include directories for the project
    foreach ($dir in $options.Includes) {
        $dir = $dir.TrimStart("\")
        $dir = JsonEscape $dir
        $command += " -I`\`"$dir`\`""
    }

    # Default compiler options
    foreach ($arg in $clangArguments) {
        $command += " $arg"
    }

    # Warnings
    if ($script:Warnings -ne $null) {
        foreach ($warning in $script:Warnings) {
            $command += " -W$warning"
        }
    }

    # System header exclusion prefixes
    if ($script:HeaderPrefixes -ne $null) {
        foreach ($prefix in $script:HeaderPrefixes) {
            $command += " --system-header-prefix=$prefix"
        }
    }

    # GCC compiler options from the AS project
    $command += " $($options.Options)"

    # File to compile
    $file = JsonEscape $file
    $command += " \`"$file\`""

    $command
}

# ------------------------------------------------------------------------------

# Locates the path of the package within the project
function FindPackagePaths($package) {
    # Create a list with absolute search paths for all packages that can have
    # header information for the specified package.
    $absolute = @()
    $parent = $package
    do {
        $package = $parent
        if ($package.Directory.Name -eq "Logical") {
            # Always skip the logical package as it's not relevant for the
            # package headers
            break
        }
        $absolute += $package.Directory
        $content = Get-ChildItem $package.Directory.Parent.FullName
        $parent= $content |
            Where-Object {$_ -like "*.pkg"} |
            Select-Object -First 1
    } while ($parent)

    # Convert the absolute to relative search paths
    [Array]::Reverse($absolute)
    $current = ""
    $relative = @()
    foreach ($directory in $absolute) {
        $current = $current + $directory.Name + "\"
        $relative += $current
    }

    [Array]::Reverse($relative)
    $relative
}

# ------------------------------------------------------------------------------

# Creates a list of packages that have additional package specific options
function FindPackageOptions($project, $packages) {
    $options = @()
    $asInclude = Join-Path $project "Temp\Includes"
    foreach ($package in $packages) {
        if ($package -like "*.prg") {
            $paths = FindPackagePaths $package
            $absolutePaths = @()
            foreach ($path in $paths) {
                $absolute = Join-Path $asInclude $path
                if (Test-Path $absolute) {
                    $absolutePaths += $absolute
                }
            }
            if ($absolutePaths) {
                $properties = @{
                    Path = $package.DirectoryName;
                    AsDefaultPaths = $absolutePaths;
                }
                $options += (New-Object PSObject -Property $properties)
            }
        }
    }
    $options
}
# ------------------------------------------------------------------------------

function FindPackageOptionsForFile($packages, $file) {
    foreach($package in $packages) {
        if ($file.FullName.StartsWith($package.Path)) {
            return $package
        }
    }
    $null
}

# ------------------------------------------------------------------------------
# Script starts here

if (!(Test-Path $Project)) {
    throw "The specified AS project $Project does not exist"
}

# Read build options from the physical configuration
$buildOptions = Invoke-Expression "& `"$optionsPath`" -Project `"$Project`" -Configuration `"$Configuration`""
if (($buildOptions.GccVersion -ne "4.1.2") -and ($buildOptions.GccVersion -ne "6.3.0")) {
    throw "The specified GCC version $($buildOptions.GccVersion) is not supported"
}

# ------------------------------------------------------------------------------
# Assign compiler flags

$clangCArguments += "-fno-ms-extensions"
$clangCppArguments += "-fno-ms-extensions"
$clangCArguments += "-fno-ms-compatibility"
$clangCppArguments += "-fno-ms-compatibility"
$clangCArguments += "-fdeclspec"
$clangCppArguments += "-fdeclspec"

# ------------------------------------------------------------------------------
# Assign default build options

$clangCArguments += "-D__STDC__"
$clangCppArguments += "-D__STDC__"
if ($buildOptions.GccVersion -ne "6.3.0") {
    $clangCArguments += "-D__STDC_VERSION__=199901L"
    $clangCppArguments += "-D__STDC_VERSION__=199901L"
}
$clangCArguments += "-D_SG4"
$clangCppArguments += "-D_SG4"
if ($AsDefault) {
    $clangCArguments += "-D_DEFAULT_INCLUDES"
    $clangCppArguments += "-D_DEFAULT_INCLUDES"
}
$clangCArguments += "-D_REPLACE_CONST"
$clangCppArguments += "-D_REPLACE_CONST"

# Since we compile against the GNU C++ libraries we need to use the correct
# C++11 version in order to get the correct defines when compiling. If not,
# there will be some library issues. This also allows us to get as close as
# possible to how AS performs the compilation.
$clangCppArguments += "-std=gnu++11"

# These are system directories that are normally included by AS
$asCDirectories = GetDefaultASIncludeDirectories $Project $buildOptions.GccVersion $false
$asCppDirectories = GetDefaultASIncludeDirectories $Project $buildOptions.GccVersion $true

# Get all C++ source files for the project
$contArgs = @{
    Directory = $Project;
    Exclude = $Exclude;
    Recursive = $true;
    References = $References;
}
$files = Invoke-Expression "& `"$contentPath`" @contArgs" | Where-Object {($_ -like "*.cpp" -or $_ -like "*.c")}

# Get all Program specific build options
if ($AsDefault) {
    $packages = .\Get-AsContent @contArgs -FileType Package
    $packageOptions = FindPackageOptions $Project $packages
}

# Create the JSON command database
$fileList = ""
Push-Location $Project
try {
    AppendL "["
    if ($files -ne $null) {
        foreach ($file in $files) {
            $fileName = Resolve-Path -Path $file -Relative
            $absFileName = Resolve-Path -Path $file
            if ($AsDefault) {
                $options = FindPackageOptionsForFile $packageOptions $file
            }
            $extn = [IO.Path]::GetExtension($fileName)
            if ($extn -eq ".cpp" ) {
              $command = MakeCommandLine $absFileName.Path $buildOptions $asCppDirectories $options $clangCppArguments
            }
            else {
              $command = MakeCommandLine $absFileName.Path $buildOptions $asCDirectories $options $clangCArguments
            }
            $escapedFile = JsonEscape $fileName
            $escapedProject = JsonEscape $Project

            AppendL "  {"
            AppendL "    `"directory`": `"$escapedProject`","
            AppendL "    `"command`": `"$command`","
            AppendL "    `"file`": `"$escapedFile`""
            AppendL "  },"

            if (!$fileList){
                $tmpPath = $absFileName.Path
#                $tmpPath = $tmpPath.replace(' ', '\ ')
                $tmpName = '"' + $tmpPath + '"'
                $fileList = $tmpName
            }
            else {
                $tmpPath = $absFileName.Path
#                $tmpPath = $tmpPath.replace(' ', '\ ')
                $tmpName = ' "' + $tmpPath +'"'
                $fileList += $tmpName
            }
        }
    }
} finally {
    AppendL "]"
    Pop-Location
}

Set-Content -Path "$DatabaseFile" -Value $content

# Create the file list
Set-Content -Path "$FileListFile" -Value $fileList
